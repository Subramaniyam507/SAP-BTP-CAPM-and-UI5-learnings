const LRUCache = require("../cache/LRUCache");
const IdentityServiceSecurityContext = require("./IdentityServiceSecurityContext");
const XsuaaSecurityContext = require("./XsuaaSecurityContext");
const { ConfigurationError } = require("../error");
const createCacheKey = require("../cache/createCacheKey");
const createSecurityContext = require("./createSecurityContext");
const { getLogger } = require("../util/logging");

const LOG = getLogger("XsuaaLegacyExtension.js");


/**
 * XsuaaLegacyExtension
 * ---------------------------------------------
 * @experimental
 * **For the time being, please use only after consulting the maintainers as the API may change again if necessary.**
 * 
 * When this context extension is added to the configuration of an `IdentityService`, it extends {@link IdentityServiceSecurityContext}s created on that service
 * by exchanging IAS user tokens for XSUAA user tokens.
 * Important: It *never* applies to XSUAA tokens or IAS technical user tokens. In these cases, the result of createSecurityContext is unaffected by this extension!
 * Non-CAP applications with hybrid authentication must be prepared to deal with both context types depending on the incoming tokens.
 *
 * By default, it will embed the XsuaaSecurityContext created from the fetched token to the optional property `xsuaaContext`:
 * 
 * IdentityServiceSecurityContext\
 *  └─ xsuaaContext: XsuaaSecurityContext
 * 
 * Alternatively, it can be configured the other way around, so that `createSecurityContext` will instead return the XsuaaSecurityContext with the original
 * IdentityServiceSecurityContext embedded inside on property `iasContext`:
 * 
 * XsuaaSecurityContext\
 *  └─ iasContext: IdentityServiceSecurityContext
 * 
 * This is controlled by passing either the IdentityServiceSecurityContext constructor or the XsuaaSecurityContext constructor to `primaryContextType`.
 *
 * Use case: Migrate XSUAA-based authentication/authorization to IAS (and optionally AMS) for some tenants.
 *  - Some tenants may still log-in via XSUAA sending XSUAA tokens 
 *    ==> createSecurityContext will always return XsuaaSecurityContext independent of this extension
 *  - Other tenants have migrated already to log-in via IAS sending IAS tokens
 *    ==> When this extension is enabled, createSecurityContext will return IdentityServiceSecurityContext with an embedded XsuaaSecurityContext or vice versa - depending on configuration
 * 
 * Hybrid applications that have not adopted AMS, can use `primaryContextType=XsuaaSecurityContext` to keep using their existing XSUAA-based authorization checks.\
 * Hybrid applications that have adopted AMS, can use `primaryContextType=IdentityServiceSecurityContext` to get the IAS context as primary one and map
 * XSUAA scopes to additional base policies for users of legacy tenants, so the existing XSUAA authorizations stay in effect until they have fully migrated user roles to AMS policies.
 *
 * Conditional application:
 *  - The method {@link appliesTo} determines per created IdentityServiceSecurityContext whether the XsuaaLegacyExtension shall be applied or not.
 *  - Default implementation: applies only to regular user tokens because technical user tokens cannot be exchanged.
 *  - You can subclass or supply an override of this method to implement additional tenant allow-lists / feature flags.
 *
 * **When the extension does not apply, createSecurityContext will result in an IdentityServiceSecurityContext, even for `primaryContextType=XsuaaSecurityContext`!**
 *
 * Token fetching logic:
 *  - If the incoming IAS token is a "weak" (app2app) token (identified by `consumedApis.length > 0`), it is first exchanged for a strong JWT by `IdentityServiceSecurityContext#getIdToken`.
 *  - Then, an XSUAA JWT is requested from the given XsuaaService using the (possibly exchanged) IAS token as assertion in a `jwt bearer` flow.
 *  - An `XsuaaSecurityContext` is created from the resulting XSUAA JWT.
 *
 * Caching:
 *  - The created XsuaaSecurityContext is cached by the original IAS token's ias_iss, jti and (if present) app_tid until 5 minutes before expiration.
 *  - Default cache: LRU cache with max size 100. A custom cache (implementing { get(key), set(key, value) }) can be configured via cache configuration using the `impl` property.
 */
class XsuaaLegacyExtension {
    /** @type {import("../util/Types").CacheConfig} */
    static DEFAULT_CACHE_CONFIG = {
        enabled: true,
        size: 100
    };

    /** @type {import("../service/XsuaaService")} */
    xsuaaService;
    /**
     * Indicates which context type should become the primary one returned to the application.
     * @type {typeof IdentityServiceSecurityContext | typeof XsuaaSecurityContext}
     */
    primaryContextType;

    /**
     * A cache used for caching XsuaaSecurityContexts. Can be either an external cache implementation or a per-instance LRUCache.
     * @type {import("../util/Types").Cache}
     */
    cache;

    /**
     * Create an XsuaaLegacyExtension instance.
     *
     * @param {import("../service/XsuaaService")} xsuaaService - XsuaaService instance used to fetch XSUAA tokens.
     * @param {typeof IdentityServiceSecurityContext | typeof XsuaaSecurityContext} [primaryContextType=IdentityServiceSecurityContext] - Which context type should be returned after token validation.
     * The other context type is attached as property to the primary one.
     * Defaults to IdentityServiceSecurityContext, meaning the XsuaaSecurityContext is attached to property `xsuaaContext`.
     * If set to XsuaaSecurityContext, the IdentityServiceSecurityContext is attached to property `iasContext`.
     * @param {import("../util/Types").CacheConfig} [cache] - Optional cache configuration. Defaults to an in-memory LRU with max size 100.
     */
    constructor(xsuaaService, primaryContextType = IdentityServiceSecurityContext, cache) {
        if (primaryContextType != null && primaryContextType !== XsuaaSecurityContext && primaryContextType !== IdentityServiceSecurityContext) {
            throw new ConfigurationError(
                `XsuaaLegacyExtension: 'primaryContextType' must be either XsuaaSecurityContext, IdentityServiceSecurityContext or null/undefined (defaults to XsuaaSecurityContext).`
            );
        }

        this.xsuaaService = xsuaaService;
        this.primaryContextType = primaryContextType;
        this.cache = this.#initializeCache(cache);
    }

    /**
     * Initialize cache from the provided cache config.
     * @private
     * @param {import("../util/Types").CacheConfig} [cache] - Cache configuration.
     * @returns {import("../util/Types").Cache} The initialized cache instance.
     */
    #initializeCache(cache) {
        cache ??= XsuaaLegacyExtension.DEFAULT_CACHE_CONFIG;

        if (cache.enabled === false || cache.size === 0) {
            return null;
        } else if (cache.impl) {
            return cache.impl;
        } else {
            const size = cache.size ?? XsuaaLegacyExtension.DEFAULT_CACHE_CONFIG.size;
            return new LRUCache(size);
        }
    }

    /**
     * Extend (augment) an IAS security context with an XSUAA context, or replace it as primary depending on `primaryContextType`.
     * @param {import("./IdentityServiceSecurityContext")} iasCtx - The initial IAS-derived security context.
     * @returns {Promise<import("./IdentityServiceSecurityContext") | import("./XsuaaSecurityContext") | undefined>} The primary context (after augmentation) or undefined if no augmentation occurred.
     */
    async extendSecurityContext(iasCtx) {
        if (await this.appliesTo(iasCtx)) {
            LOG.debug?.(`Applying extension to SAP Identity Service token with app_tid='${iasCtx.token.appTid}'.`);
            const xsuaaContext = await this.getXsuaaContext(iasCtx);
            if (this.primaryContextType === IdentityServiceSecurityContext) {
                iasCtx.xsuaaContext = xsuaaContext;
                LOG.debug?.(`Successfully embedded XsuaaSecurityContext under property 'xsuaaContext'.`);
                return iasCtx;
            } else if (this.primaryContextType === XsuaaSecurityContext) {
                xsuaaContext.iasContext = iasCtx;
                LOG.debug?.(`Successfully swapped IdentityServiceSecurityContext to an XsuaaSecurityContext with original context embedded under 'iasContext' property.`);
                return xsuaaContext;
            }
        } else {
            LOG.debug?.(`Skipped extension for SAP Identity Service token with app_tid='${iasCtx.token.appTid}'.`);
        }
    }

    /**
     * Decides whether the extension should fetch an XsuaaSecurityContext for the given IdentityServiceSecurityContext.
     * Override this for custom logic, e.g. decision per tenant.
     * Default: applies to user tokens only (`sub !== azp`).
     * @param {import("./IdentityServiceSecurityContext")} iasCtx
     * @returns {Promise<boolean>}
     */
    async appliesTo(iasCtx) {
        return iasCtx.token.subject !== iasCtx.token.azp;
    }

    /**
     * Obtain (and cache) an XsuaaSecurityContext corresponding to the provided IdentityServiceSecurityContext.
     * Handles weak-token exchange (app2app) before requesting an XSUAA JWT.
     * @param {import("./IdentityServiceSecurityContext")} iasCtx
     * @returns {Promise<import("./XsuaaSecurityContext")>}
     */
    async getXsuaaContext(iasCtx) {
        const iasToken = iasCtx.token;

        let cacheKey = createCacheKey({
            ias_iss: iasToken.issuer,
            app_tid: iasToken.appTid || '',
            jti: iasToken.payload.jti
        });

        /** @type {XsuaaSecurityContext|null|undefined} */
        const cachedXsuaaContext = this.cache?.get(cacheKey);
        if (cachedXsuaaContext) {
            if (cachedXsuaaContext.token.remainingTime >= 300) {
                // tokens with a minimum remaining time of 5 minutes may be returned from cache
                LOG.debug?.(`Returning cached XsuaaSecurityContext for IAS token with app_tid='${iasToken.appTid}', jti='${iasToken.payload.jti}', ias_iss='${iasToken.issuer}'.`);
                return cachedXsuaaContext;
            } else {
                // remove almost expired token from cache
                LOG.debug?.(`Removing almost expired cached XsuaaSecurityContext for IAS token with app_tid='${iasToken.appTid}', jti='${iasToken.payload.jti}', ias_iss='${iasToken.issuer}'.`);
                this.cache.set(cacheKey, null);
            }
        }
        
        const idToken = await iasCtx.getIdToken();
        LOG.debug?.(`Fetching XSUAA token for IAS token with app_tid='${iasToken.appTid}', jti='${iasToken.payload.jti}', ias_iss='${iasToken.issuer}'.`);
        const xsuaaJwt = (await this.xsuaaService.fetchJwtBearerToken(idToken, {
            zid: idToken.appTid
        })).access_token;

        const xsuaaContext = await createSecurityContext(this.xsuaaService, {
            ...iasCtx.config,
            jwt: xsuaaJwt,
            token: undefined,
            skipValidation: true // token fetched from XsuaaService can be trusted
        });

        this.cache?.set(cacheKey, xsuaaContext);
        return xsuaaContext;
    }
}

module.exports = XsuaaLegacyExtension;
