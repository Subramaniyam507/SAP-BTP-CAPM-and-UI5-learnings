export = XsuaaLegacyExtension;
/**
 * XsuaaLegacyExtension
 * ---------------------------------------------
 * @experimental
 * **For the time being, please use only after consulting the maintainers as the API may change again if necessary.**
 *
 * When this context extension is added to the configuration of an `IdentityService`, it extends {@link IdentityServiceSecurityContext}s created on that service
 * by exchanging IAS user tokens for XSUAA user tokens.
 * Important: It *never* applies to XSUAA tokens or IAS technical user tokens. In these cases, the result of createSecurityContext is unaffected by this extension!
 * Non-CAP applications with hybrid authentication must be prepared to deal with both context types depending on the incoming tokens.
 *
 * By default, it will embed the XsuaaSecurityContext created from the fetched token to the optional property `xsuaaContext`:
 *
 * IdentityServiceSecurityContext\
 *  └─ xsuaaContext: XsuaaSecurityContext
 *
 * Alternatively, it can be configured the other way around, so that `createSecurityContext` will instead return the XsuaaSecurityContext with the original
 * IdentityServiceSecurityContext embedded inside on property `iasContext`:
 *
 * XsuaaSecurityContext\
 *  └─ iasContext: IdentityServiceSecurityContext
 *
 * This is controlled by passing either the IdentityServiceSecurityContext constructor or the XsuaaSecurityContext constructor to `primaryContextType`.
 *
 * Use case: Migrate XSUAA-based authentication/authorization to IAS (and optionally AMS) for some tenants.
 *  - Some tenants may still log-in via XSUAA sending XSUAA tokens
 *    ==> createSecurityContext will always return XsuaaSecurityContext independent of this extension
 *  - Other tenants have migrated already to log-in via IAS sending IAS tokens
 *    ==> When this extension is enabled, createSecurityContext will return IdentityServiceSecurityContext with an embedded XsuaaSecurityContext or vice versa - depending on configuration
 *
 * Hybrid applications that have not adopted AMS, can use `primaryContextType=XsuaaSecurityContext` to keep using their existing XSUAA-based authorization checks.\
 * Hybrid applications that have adopted AMS, can use `primaryContextType=IdentityServiceSecurityContext` to get the IAS context as primary one and map
 * XSUAA scopes to additional base policies for users of legacy tenants, so the existing XSUAA authorizations stay in effect until they have fully migrated user roles to AMS policies.
 *
 * Conditional application:
 *  - The method {@link appliesTo} determines per created IdentityServiceSecurityContext whether the XsuaaLegacyExtension shall be applied or not.
 *  - Default implementation: applies only to regular user tokens because technical user tokens cannot be exchanged.
 *  - You can subclass or supply an override of this method to implement additional tenant allow-lists / feature flags.
 *
 * **When the extension does not apply, createSecurityContext will result in an IdentityServiceSecurityContext, even for `primaryContextType=XsuaaSecurityContext`!**
 *
 * Token fetching logic:
 *  - If the incoming IAS token is a "weak" (app2app) token (identified by `consumedApis.length > 0`), it is first exchanged for a strong JWT by `IdentityServiceSecurityContext#getIdToken`.
 *  - Then, an XSUAA JWT is requested from the given XsuaaService using the (possibly exchanged) IAS token as assertion in a `jwt bearer` flow.
 *  - An `XsuaaSecurityContext` is created from the resulting XSUAA JWT.
 *
 * Caching:
 *  - The created XsuaaSecurityContext is cached by the original IAS token's ias_iss, jti and (if present) app_tid until 5 minutes before expiration.
 *  - Default cache: LRU cache with max size 100. A custom cache (implementing { get(key), set(key, value) }) can be configured via cache configuration using the `impl` property.
 */
declare class XsuaaLegacyExtension {
    /** @type {import("../util/Types").CacheConfig} */
    static DEFAULT_CACHE_CONFIG: import("../util/Types").CacheConfig;
    /**
     * Create an XsuaaLegacyExtension instance.
     *
     * @param {import("../service/XsuaaService")} xsuaaService - XsuaaService instance used to fetch XSUAA tokens.
     * @param {typeof IdentityServiceSecurityContext | typeof XsuaaSecurityContext} [primaryContextType=IdentityServiceSecurityContext] - Which context type should be returned after token validation.
     * The other context type is attached as property to the primary one.
     * Defaults to IdentityServiceSecurityContext, meaning the XsuaaSecurityContext is attached to property `xsuaaContext`.
     * If set to XsuaaSecurityContext, the IdentityServiceSecurityContext is attached to property `iasContext`.
     * @param {import("../util/Types").CacheConfig} [cache] - Optional cache configuration. Defaults to an in-memory LRU with max size 100.
     */
    constructor(xsuaaService: import("../service/XsuaaService"), primaryContextType?: typeof IdentityServiceSecurityContext | typeof XsuaaSecurityContext, cache?: import("../util/Types").CacheConfig);
    /** @type {import("../service/XsuaaService")} */
    xsuaaService: import("../service/XsuaaService");
    /**
     * Indicates which context type should become the primary one returned to the application.
     * @type {typeof IdentityServiceSecurityContext | typeof XsuaaSecurityContext}
     */
    primaryContextType: typeof IdentityServiceSecurityContext | typeof XsuaaSecurityContext;
    /**
     * A cache used for caching XsuaaSecurityContexts. Can be either an external cache implementation or a per-instance LRUCache.
     * @type {import("../util/Types").Cache}
     */
    cache: import("../util/Types").Cache;
    /**
     * Extend (augment) an IAS security context with an XSUAA context, or replace it as primary depending on `primaryContextType`.
     * @param {import("./IdentityServiceSecurityContext")} iasCtx - The initial IAS-derived security context.
     * @returns {Promise<import("./IdentityServiceSecurityContext") | import("./XsuaaSecurityContext") | undefined>} The primary context (after augmentation) or undefined if no augmentation occurred.
     */
    extendSecurityContext(iasCtx: import("./IdentityServiceSecurityContext")): Promise<import("./IdentityServiceSecurityContext") | import("./XsuaaSecurityContext") | undefined>;
    /**
     * Decides whether the extension should fetch an XsuaaSecurityContext for the given IdentityServiceSecurityContext.
     * Override this for custom logic, e.g. decision per tenant.
     * Default: applies to user tokens only (`sub !== azp`).
     * @param {import("./IdentityServiceSecurityContext")} iasCtx
     * @returns {Promise<boolean>}
     */
    appliesTo(iasCtx: import("./IdentityServiceSecurityContext")): Promise<boolean>;
    /**
     * Obtain (and cache) an XsuaaSecurityContext corresponding to the provided IdentityServiceSecurityContext.
     * Handles weak-token exchange (app2app) before requesting an XSUAA JWT.
     * @param {import("./IdentityServiceSecurityContext")} iasCtx
     * @returns {Promise<import("./XsuaaSecurityContext")>}
     */
    getXsuaaContext(iasCtx: import("./IdentityServiceSecurityContext")): Promise<import("./XsuaaSecurityContext")>;
    #private;
}
import IdentityServiceSecurityContext = require("./IdentityServiceSecurityContext");
import XsuaaSecurityContext = require("./XsuaaSecurityContext");
//# sourceMappingURL=XsuaaLegacyExtension.d.ts.map