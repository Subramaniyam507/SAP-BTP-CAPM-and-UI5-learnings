import type { Answers, Question, Validator } from 'inquirer';
import type { CommonPromptOptions, PromptDefaultValue, PromptSeverityMessage, YUIQuestion } from '../types';
import type { ConvertedMetadata, EntitySet } from '@sap-ux/vocabularies-types';
/**
 * Extends an additionalMessages function.
 *
 * @param question - the question to which the validate function will be applied
 * @param addMsgFunc - the additional messages function which will be applied to the question
 * @param promptState - the runtime state of the prompts, this can be used to provide additional answers not defined by the prompt answers object
 * @returns the extended additional messages function
 */
export declare function extendAdditionalMessages(question: YUIQuestion, addMsgFunc: PromptSeverityMessage, promptState?: Answers): PromptSeverityMessage;
/**
 * Extends a validate function. The extended function will be called first.
 *
 * @param question - the question to which the validate function will be applied
 * @param validateFunc - the validate function which will be applied to the question
 * @param promptState - the runtime state of the prompts, this can be used to provide additional answers not defined by the prompt answers object
 * @returns the extended validate function
 */
export declare function extendValidate<T extends Answers = Answers>(question: Question, validateFunc: NonNullable<Validator<T>>, promptState?: Answers): NonNullable<Validator<T>>;
/**
 * Extend the existing prompt property function with the one specified in prompt options or add as new.
 *
 * @param question - the question to which the extending function will be applied
 * @param promptOption - prompt options, containing extending functions
 * @param funcName - the question property (function) name to extend
 * @param promptState - the runtime state of the prompts, this can be used to provide additional answers not defined by the prompt answers object
 * @returns the extended question
 */
export declare function applyExtensionFunction<T extends Answers = Answers>(question: YUIQuestion, promptOption: CommonPromptOptions<T>, funcName: 'validate' | 'additionalMessages', promptState?: Answers): YUIQuestion;
/**
 * Adds additional conditions to the provided questions.
 *
 * @param questions the questions to which the condition will be added
 * @param condition function which returns true or false
 * @returns the passed questions reference
 */
export declare function withCondition(questions: Question[], condition: (answers: Answers) => boolean): Question[];
/**
 * Updates questions with extensions for specific properties. Only `validate`, `default` and `additionalMessages` are currently supported.
 *
 * @param questions - array of prompts to be extended
 * @param promptOptions - the prompt options possibly containing function extensions
 * @param promptState - the runtime state of the prompts, this can be used to provide additional answers not defined by the prompt answers object
 * @returns - the extended questions
 */
export declare function extendWithOptions<T extends YUIQuestion = YUIQuestion>(questions: T[], promptOptions: Record<string, Omit<CommonPromptOptions, 'hide'> & PromptDefaultValue<string | boolean>>, promptState?: Answers): YUIQuestion[];
/**
 * Required transformations for analytical table support.
 * NOTE: This constant is primarily used by odata-service-inquirer but is exported
 * here to maintain backward compatibility with external packages that import it.
 */
export declare const transformationsRequiredForAnalyticalTable: readonly ["filter", "identity", "orderby", "search", "skip", "top", "groupby", "aggregate", "concat"];
/**
 * Checks if the given entity set has aggregate transformations.
 * Returns true if ANY transformations are present in either entity set or entity type annotations.
 *
 * @param entitySet The entity set to check for aggregate transformations.
 * @returns true if the entity set has any aggregate transformations, false otherwise.
 */
export declare function hasAggregateTransformations(entitySet: EntitySet): boolean;
/**
 * Returns only entity sets that have the `Aggregation.ApplySupported` annotation term with the `Transformations` property.
 * This can be found within the entity set annotations or the entity type annotations.
 *
 * @param entitySets the entity sets to filter
 * @returns the filtered entity sets
 */
export declare function filterAggregateTransformations(entitySets: EntitySet[]): EntitySet[];
/**
 * Checks if the given entity set name has aggregate transformations in the metadata.
 * If specific transformations are provided, checks if ALL of those transformations are present.
 * If no transformations are specified, returns true if ANY transformations are present.
 *
 * @param metadata The metadata (edmx) of the service.
 * @param entitySetName The entity set name to check for aggregate transformations.
 * @param requiredTransformations Optional array of specific transformations to check for. If not provided, checks for any transformations.
 * @returns true if the entity set has the required transformations, false otherwise.
 */
export declare function hasAggregateTransformationsForEntity(metadata: ConvertedMetadata, entitySetName?: string, requiredTransformations?: readonly string[]): boolean;
/**
 * Checks if the given entity set name has a Hierarchy.RecursiveHierarchy annotation in the metadata.
 *
 * @param metadata The metadata (edmx) of the service.
 * @param entitySetName The entity set name to check for recursive hierarchy annotation.
 * @returns true if the entity set has Hierarchy.RecursiveHierarchy annotation, false otherwise.
 */
export declare function hasRecursiveHierarchyForEntity(metadata: ConvertedMetadata, entitySetName?: string): boolean;
/**
 * Gets the qualifier from a Hierarchy.RecursiveHierarchy annotation for the given entity set.
 *
 * @param metadata The metadata (edmx) of the service.
 * @param entitySetName The entity set name to check for recursive hierarchy annotation.
 * @returns The qualifier string if found, undefined otherwise.
 */
export declare function getRecursiveHierarchyQualifier(metadata: ConvertedMetadata, entitySetName?: string): string | undefined;
/**
 * Checks if the given entity set has aggregate transformations.
 * If specific transformations are provided, checks if ALL of those transformations are present.
 * If no transformations are specified, returns true if ANY transformations are present.
 *
 * @param entitySet The entity set to check for aggregate transformations.
 * @param requiredTransformations Optional array of specific transformations to check for. If not provided, checks for any transformations.
 * @returns true if the entity set has the required transformations, false otherwise.
 */
export declare function hasAggregateTransformationsForEntitySet(entitySet: EntitySet, requiredTransformations?: readonly string[]): boolean;
/**
 * Checks if the given entity set has a Hierarchy.RecursiveHierarchy annotation.
 *
 * @param entitySet The entity set to check for recursive hierarchy annotation.
 * @returns true if the entity set has Hierarchy.RecursiveHierarchy annotation, false otherwise.
 */
export declare function hasRecursiveHierarchyForEntitySet(entitySet: EntitySet): boolean;
/**
 * Gets the qualifier from a Hierarchy.RecursiveHierarchy annotation for the given entity set.
 *
 * @param entitySet The entity set to check for recursive hierarchy annotation.
 * @returns The qualifier string if found, undefined otherwise.
 */
export declare function getRecursiveHierarchyQualifierForEntitySet(entitySet: EntitySet): string | undefined;
/**
 * Finds an entity set by name in the metadata.
 *
 * @param metadata The metadata (edmx) of the service.
 * @param entitySetName The name of the entity set to find.
 * @returns The entity set if found, undefined otherwise.
 */
export declare function findEntitySetByName(metadata: ConvertedMetadata, entitySetName: string): EntitySet | undefined;
/**
 * Converts an EDMX string to a ConvertedMetadata object.
 *
 * @param edmx - The EDMX string to convert.
 * @returns The converted metadata object.
 * @throws If the EDMX cannot be parsed or the OData version is unparseable.
 */
export declare function convertEdmxToConvertedMetadata(edmx: string): ConvertedMetadata;
//# sourceMappingURL=helpers.d.ts.map