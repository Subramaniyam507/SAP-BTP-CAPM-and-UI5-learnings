"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApprouterType = getApprouterType;
exports.getModuleNames = getModuleNames;
exports.getServicesForFile = getServicesForFile;
exports.hasApprouter = hasApprouter;
exports.getMtaServices = getMtaServices;
exports.getResources = getResources;
exports.readMta = readMta;
const path = __importStar(require("node:path"));
const i18n_1 = require("../../i18n");
const yaml_1 = require("./yaml");
const yaml_loader_1 = require("./yaml-loader");
const cli_1 = require("../services/cli");
/**
 * Get the approuter type.
 *
 * @param {string} mtaProjectPath - The path to the mta project.
 * @returns {AppRouterType} The approuter type.
 */
function getApprouterType(mtaProjectPath) {
    const yamlContent = (0, yaml_loader_1.getYamlContent)(path.join(mtaProjectPath, 'mta.yaml'));
    return (0, yaml_1.getRouterType)(yamlContent);
}
/**
 * Get the module names.
 *
 * @param {string} mtaProjectPath - The path to the mta project.
 * @returns {string[]} The module names.
 */
function getModuleNames(mtaProjectPath) {
    const yamlContent = (0, yaml_loader_1.getYamlContent)(path.join(mtaProjectPath, 'mta.yaml'));
    return yamlContent?.modules?.map((module) => module.name) ?? [];
}
/**
 * Get the services for the file.
 *
 * @param {string} mtaFilePath - The path to the mta file.
 * @param {ToolsLogger} logger - The logger.
 * @returns {BusinessServiceResource[]} The services.
 */
function getServicesForFile(mtaFilePath, logger) {
    const serviceNames = [];
    const parsed = (0, yaml_loader_1.getYamlContent)(mtaFilePath);
    if (parsed?.resources && Array.isArray(parsed.resources)) {
        for (const resource of parsed.resources) {
            const name = resource?.parameters?.['service-name'] ?? resource.name;
            const label = resource?.parameters?.service;
            if (name) {
                serviceNames.push({ name, label });
                if (!label) {
                    logger?.log(`Service '${name}' will be ignored without 'service' parameter`);
                }
            }
        }
    }
    return serviceNames;
}
/**
 * Check if the project has an approuter.
 *
 * @param {string} projectName - The project name.
 * @param {string[]} moduleNames - The module names.
 * @returns {boolean} Whether the project has an approuter.
 */
function hasApprouter(projectName, moduleNames) {
    return moduleNames.some((name) => name === `${projectName.toLowerCase()}-destination-content` ||
        name === `${projectName.toLowerCase()}-approuter`);
}
/**
 * Filter services based on the business services.
 *
 * @param {BusinessServiceResource[]} businessServices - The business services.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<string[]>} The filtered services.
 */
async function filterServices(businessServices, logger) {
    const serviceLabels = businessServices.map((service) => service.label).filter(Boolean);
    if (serviceLabels.length === 0) {
        throw new Error((0, i18n_1.t)('error.noBusinessServicesFound'));
    }
    const url = `/v3/service_offerings?names=${serviceLabels.join(',')}`;
    const json = await (0, cli_1.requestCfApi)(url);
    logger?.log(`Filtering services. Request to: ${url}, result: ${JSON.stringify(json)}`);
    const businessServiceNames = new Set(businessServices.map((service) => service.label));
    const result = [];
    for (const resource of json?.resources ?? []) {
        if (businessServiceNames.has(resource.name)) {
            const sapService = resource?.['broker_catalog']?.metadata?.sapservice;
            if (sapService && ['v2', 'v4'].includes(sapService?.odataversion ?? '')) {
                result.push(businessServices?.find((service) => resource.name === service.label)?.name ?? '');
            }
            else {
                logger?.log(`Service '${resource.name}' doesn't support V2/V4 Odata and will be ignored`);
            }
        }
    }
    if (result.length === 0) {
        throw new Error((0, i18n_1.t)('error.noBusinessServicesFound'));
    }
    return result;
}
/**
 * Get the services for the MTA project.
 *
 * @param {string} projectPath - The path to the project.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<string[]>} The services.
 */
async function getMtaServices(projectPath, logger) {
    const services = await readMta(projectPath, logger);
    logger?.log(`Available services defined in mta.yaml: ${JSON.stringify(services)}`);
    return services;
}
/**
 * Get the resources for the MTA file.
 *
 * @param {string} mtaFilePath - The path to the mta file.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<string[]>} The resources.
 */
async function getResources(mtaFilePath, logger) {
    const servicesList = getServicesForFile(mtaFilePath, logger);
    const oDataFilteredServices = await filterServices(servicesList, logger);
    return oDataFilteredServices;
}
/**
 * Read the MTA file.
 *
 * @param {string} projectPath - The path to the project.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<string[]>} The resources.
 */
async function readMta(projectPath, logger) {
    if (!projectPath) {
        throw new Error((0, i18n_1.t)('error.mtaProjectPathMissing'));
    }
    const mtaFilePath = path.resolve(projectPath, 'mta.yaml');
    const resources = await getResources(mtaFilePath, logger);
    return resources;
}
//# sourceMappingURL=mta.js.map