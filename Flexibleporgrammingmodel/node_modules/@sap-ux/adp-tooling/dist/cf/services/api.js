"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBusinessServiceKeys = getBusinessServiceKeys;
exports.getFDCRequestArguments = getFDCRequestArguments;
exports.getFDCApps = getFDCApps;
exports.createService = createService;
exports.createServices = createServices;
exports.getServiceInstanceKeys = getServiceInstanceKeys;
const fs = __importStar(require("node:fs"));
const axios_1 = __importDefault(require("axios"));
const path = __importStar(require("node:path"));
const CFToolsCli = require("@sap/cf-tools/out/src/cli");
const btp_utils_1 = require("@sap-ux/btp-utils");
const i18n_1 = require("../../i18n");
const project_1 = require("../project");
const cli_1 = require("./cli");
const PARAM_MAP = new Map([
    ['spaceGuids', 'space_guids'],
    ['planNames', 'service_plan_names'],
    ['names', 'names']
]);
/**
 * Get the business service keys.
 *
 * @param {string} businessService - The business service.
 * @param {CfConfig} config - The CF config.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<ServiceKeys | null>} The service keys.
 */
async function getBusinessServiceKeys(businessService, config, logger) {
    const serviceKeys = await getServiceInstanceKeys({
        spaceGuids: [config.space.GUID],
        names: [businessService]
    }, logger);
    logger?.log(`Available service key instance : ${JSON.stringify(serviceKeys?.serviceInstance)}`);
    return serviceKeys;
}
/**
 * Get the FDC request arguments.
 *
 * @param {CfConfig} cfConfig - The CF config.
 * @returns {RequestArguments} The request arguments.
 */
function getFDCRequestArguments(cfConfig) {
    const fdcUrl = 'https://ui5-flexibility-design-and-configuration.';
    const cfApiEndpoint = `https://api.cf.${cfConfig.url}`;
    const endpointParts = /https:\/\/api\.cf(?:\.([^-.]*)(-\d+)?(\.hana\.ondemand\.com)|(.*))/.exec(cfApiEndpoint);
    const options = {
        withCredentials: true,
        headers: {
            'Content-Type': 'application/json'
        }
    };
    let url;
    if (endpointParts?.[3]) {
        // Public cloud - use mTLS enabled domain with "cert" prefix
        const region = endpointParts[1];
        url = `${fdcUrl}cert.cfapps.${region}.hana.ondemand.com`;
    }
    else if (endpointParts?.[4]?.endsWith('.cn')) {
        // China has a special URL pattern
        const parts = endpointParts[4].split('.');
        parts.splice(2, 0, 'apps');
        url = `${fdcUrl}sapui5flex${parts.join('.')}`;
    }
    else {
        url = `${fdcUrl}sapui5flex.cfapps${endpointParts?.[4]}`;
    }
    // Add authorization token for non-BAS environments or private cloud
    // For BAS environments with mTLS, the certificate authentication is handled automatically
    if (!(0, btp_utils_1.isAppStudio)() || !endpointParts?.[3]) {
        options.headers['Authorization'] = `Bearer ${cfConfig.token}`;
    }
    return {
        url: url,
        options
    };
}
/**
 * Get the FDC apps.
 *
 * @param {string[]} appHostIds - The app host ids.
 * @param {CfConfig} cfConfig - The CF config.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<FDCResponse>} The FDC apps.
 */
async function getFDCApps(appHostIds, cfConfig, logger) {
    const requestArguments = getFDCRequestArguments(cfConfig);
    logger?.log(`App Hosts: ${JSON.stringify(appHostIds)}, request arguments: ${JSON.stringify(requestArguments)}`);
    const appHostIdParams = appHostIds.map((id) => `appHostId=${encodeURIComponent(id)}`).join('&');
    const url = `${requestArguments.url}/api/business-service/discovery?${appHostIdParams}`;
    try {
        const response = await axios_1.default.get(url, requestArguments.options);
        if (response.status === 200) {
            logger?.log(`Retrieved FDC apps with request url: ${JSON.stringify(response.data)}`);
            return response.data.results;
        }
        else {
            throw new Error((0, i18n_1.t)('error.failedToConnectToFDCService', { status: response.status }));
        }
    }
    catch (error) {
        logger?.error(`Getting FDC apps failed. Request url: ${url}. ${error}`);
        throw new Error((0, i18n_1.t)('error.failedToGetFDCApps', { error: error.message }));
    }
}
/**
 * Creates a service.
 *
 * @param {string} spaceGuid - The space GUID.
 * @param {string} plan - The plan.
 * @param {string} serviceInstanceName - The service instance name.
 * @param {string[]} tags - The tags.
 * @param {string} [serviceName] - The service name.
 * @param {object} [security] - Security configuration.
 * @param {string | null} security.filePath - The security file path.
 * @param {string} [security.xsappname] - The XS app name.
 * @param {string} [templatePathOverwrite] - The template path overwrite.
 * @param {ToolsLogger} [logger] - The logger.
 */
async function createService(spaceGuid, plan, serviceInstanceName, tags, serviceName, security, templatePathOverwrite, logger) {
    try {
        const { filePath, xsappname } = security ?? {};
        if (!serviceName) {
            const json = await (0, cli_1.requestCfApi)(`/v3/service_offerings?per_page=1000&space_guids=${spaceGuid}`);
            const serviceOffering = json?.resources?.find((resource) => resource.tags && tags.every((tag) => resource.tags?.includes(tag)));
            serviceName = serviceOffering?.name;
        }
        logger?.log(`Creating service instance '${serviceInstanceName}' of service '${serviceName}' with '${plan}' plan`);
        const commandParameters = ['create-service', serviceName ?? '', plan, serviceInstanceName];
        if (filePath) {
            let xsSecurity = null;
            try {
                const baseTmplPath = path.join(__dirname, '../../../templates');
                const templatePath = templatePathOverwrite ?? baseTmplPath;
                const filePath = path.resolve(templatePath, 'cf/xs-security.json');
                const xsContent = fs.readFileSync(filePath, 'utf-8');
                xsSecurity = JSON.parse(xsContent);
                xsSecurity.xsappname = xsappname;
            }
            catch (err) {
                logger?.error(`Failed to parse xs-security.json file: ${err}`);
                throw new Error((0, i18n_1.t)('error.xsSecurityJsonCouldNotBeParsed'));
            }
            commandParameters.push('-c', JSON.stringify(xsSecurity));
        }
        await CFToolsCli.Cli.execute(commandParameters);
        logger?.log(`Service instance '${serviceInstanceName}' created successfully`);
    }
    catch (e) {
        logger?.error(e);
        throw new Error((0, i18n_1.t)('error.failedToCreateServiceInstance', { serviceInstanceName, error: e.message }));
    }
}
/**
 * Creates the services.
 *
 * @param {string} projectPath - The project path.
 * @param {MtaYaml} yamlContent - The YAML content.
 * @param {string[]} initialServices - The initial services.
 * @param {string} timestamp - The timestamp.
 * @param {string} spaceGuid - The space GUID.
 * @param {string} [templatePathOverwrite] - The template path overwrite.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<void>} The promise.
 */
async function createServices(projectPath, yamlContent, initialServices, timestamp, spaceGuid, templatePathOverwrite, logger) {
    const excludeServices = new Set([...initialServices, 'portal', 'html5-apps-repo']);
    const xsSecurityPath = path.join(projectPath, 'xs-security.json');
    const xsSecurityProjectName = (0, project_1.getProjectNameForXsSecurity)(yamlContent, timestamp);
    for (const resource of yamlContent.resources ?? []) {
        if (!excludeServices.has(resource?.parameters?.service ?? '')) {
            if (resource?.parameters?.service === 'xsuaa') {
                await createService(spaceGuid, resource.parameters['service-plan'] ?? '', resource.parameters['service-name'] ?? '', [], resource.parameters.service, { filePath: xsSecurityPath, xsappname: xsSecurityProjectName }, templatePathOverwrite, logger);
            }
            else {
                await createService(spaceGuid, resource.parameters['service-plan'] ?? '', resource.parameters['service-name'] ?? '', [], resource.parameters.service, { filePath: null, xsappname: xsSecurityProjectName }, templatePathOverwrite, logger);
            }
        }
    }
}
/**
 * Gets the service instance keys.
 *
 * @param {GetServiceInstanceParams} serviceInstanceQuery - The service instance query.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<ServiceKeys | null>} The service instance keys.
 */
async function getServiceInstanceKeys(serviceInstanceQuery, logger) {
    try {
        const serviceInstances = await getServiceInstance(serviceInstanceQuery);
        if (serviceInstances?.length > 0) {
            // We can use any instance in the list to connect to HTML5 Repo
            logger?.log(`Use '${serviceInstances[0].name}' HTML5 Repo instance`);
            return {
                credentials: await getOrCreateServiceKeys(serviceInstances[0], logger),
                serviceInstance: serviceInstances[0]
            };
        }
        return null;
    }
    catch (e) {
        const errorMessage = (0, i18n_1.t)('error.failedToGetServiceInstanceKeys', { error: e.message });
        logger?.error(errorMessage);
        throw new Error(errorMessage);
    }
}
/**
 * Gets the service instance.
 *
 * @param {GetServiceInstanceParams} params - The service instance parameters.
 * @returns {Promise<ServiceInstance[]>} The service instance.
 */
async function getServiceInstance(params) {
    const parameters = Object.entries(params)
        .filter(([_, value]) => value?.length > 0)
        .map(([key, value]) => `${PARAM_MAP.get(key)}=${value.join(',')}`);
    const uriParameters = parameters.length > 0 ? `?${parameters.join('&')}` : '';
    const uri = `/v3/service_instances` + uriParameters;
    try {
        const json = await (0, cli_1.requestCfApi)(uri);
        if (!json?.resources || !Array.isArray(json.resources)) {
            throw new Error((0, i18n_1.t)('error.noValidJsonForServiceInstance'));
        }
        return json.resources.map((service) => ({
            name: service.name,
            guid: service.guid
        }));
    }
    catch (e) {
        throw new Error((0, i18n_1.t)('error.failedToGetServiceInstance', { uriParameters, error: e.message }));
    }
}
/**
 * Gets the service instance keys.
 *
 * @param {ServiceInstance} serviceInstance - The service instance.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<ServiceKeys | null>} The service instance keys.
 */
async function getOrCreateServiceKeys(serviceInstance, logger) {
    const serviceInstanceName = serviceInstance.name;
    try {
        const credentials = await (0, cli_1.getServiceKeys)(serviceInstance.guid);
        if (credentials?.length > 0) {
            return credentials;
        }
        else {
            const serviceKeyName = serviceInstanceName + '_key';
            logger?.log(`Creating service key '${serviceKeyName}' for service instance '${serviceInstanceName}'`);
            await (0, cli_1.createServiceKey)(serviceInstanceName, serviceKeyName);
            return (0, cli_1.getServiceKeys)(serviceInstance.guid);
        }
    }
    catch (e) {
        throw new Error((0, i18n_1.t)('error.failedToGetOrCreateServiceKeys', { serviceInstanceName, error: e.message }));
    }
}
//# sourceMappingURL=api.js.map